<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">173</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/395.htm' target='right' class='orange' >res文件夹下放置的是各种资源文件，比如图片文件，布局文件等。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">174</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>resources存放的是本地文件，在项目中存放的是已经训练好的分类器文件。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">175</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Gradle Scripts存放的是Gradle脚本，如下图所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">176</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-2 gradle脚本</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">177</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中build.gradle表示Project或者Module的构建脚本。</span><span class='green'>Proguard-rules.pro表示混淆规则。</span><span class='green'>gradle.properties表示gradle特性，可以对构建过程进行设置。</span><span class='green'>setting.gradle可以对Gradle的Module进行管理。</span><span class='green'>可以通过local.properties对SDK或NDK进行管理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">178</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2 视频预览实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">179</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>视频预览的实现涉及到Android的SurfaceView类和SurfaceView类。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">180</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>SurfaceView继承于View，可以直接从内存或者DMA等硬件接口取得图像数据。</span><span class='green'>它的特点是：</span><span class='green'>通常在Android中，UI的绘制只能在主线程中进行，但是在绘图频繁进行的情况下，主线程会被阻塞，而SurfaceView可以实现在主线程以外的线程进行图片的绘制，从而提高了程序的反应速度。</span><span class='green'>在游戏开发中经常会使用到SurfaceView，可以用于摄像头预览。</span><span class='green'>使用SurfaceView需要继承SurfaceView，并且实现SurfaceView的Callback接口，如下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">181</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在构造函数中首先为SurfaceView的Holder添加一个实现了Callback的回调。</span><span class='green'>这个Callback有3个回调函数：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">182</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在这3个回调函数里对Camera进行操作。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">183</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/414.htm' target='right' class='orange' >Camera类是Android中对摄像头进行操作的一个类。</a><span class='green'>可以通过Camera.open()来获取一个Camera实例，然后通过setPreviewDisplay方法来为Camera设置一个SurfaceView对象作为预览容器。</span><a href='../sentence_detail/416.htm' target='right' class='orange' >可以通过Camera.Parameters来对Camera的参数进行一些设置，比如预览的大小和摄像头预览的方向。</a><span class='green'>通过为camera设置一个PreviewCallback，来获取每帧图像的回调。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">184</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，已经完成了预览的流程。</span><span class='green'>实现效果如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">185</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-3视频预览画面</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">186</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.3 人脸检测实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">187</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在上一节中提到需要为Camera对象设置一个PreviewCallback回调。</span><span class='green'>创建了一个继承于View的FaceView来负责人脸信息的绘制。</span><span class='green'>FaceView实现了Camera的PreviewCallback，重写了onPreviewFrame方法。</span><span class='green'>OnPreviewFrame接收摄像头获取到的图像数据，每当获取到一帧，就回调一次。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">188</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/427.htm' target='right' class='orange' >FaceRecognizer类负责人脸检测和人脸识别。</a><span class='green'>在FaceView的构造函数中，对FaceRecognizer进行了初始化。</span><a href='../sentence_detail/429.htm' target='right' class='orange' >人脸检测的初始化是加载分类器，分类器保存在resources文件夹中。</a><a href='../sentence_detail/430.htm' target='right' class='orange' >由于加载分类器是一个耗时操作，因此要放到一个新的线程中使用。</a><a href='../sentence_detail/431.htm' target='right' class='orange' >主要使用JavaCV的CVHaarClassifierCascade类，在初始化时只需要传入分类器文件的路径。</a><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">189</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于加载分类器是一个耗时的操作，因此会新开一个线程进行加载，在完成加载后调用主线程创建的 Handler来发送一个消息给主线程，</span><span class='green'>表明加载完成，然后进行相应的 UI更新。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">190</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>而当FaceView接收到预览图像一帧的回调时，将获取到的图像数据传递给FaceRecognizer对象。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">191</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在processImage方法中会先将获取到的图像转换成OpenCV中图片的数据结构，即IplImage。</span><span class='green'>直接调用IplImage的create方法即可。</span><span class='green'>在将其转换成IplImage之后再将其转换成灰度图。</span><span class='green'>具体实现代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">192</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>进行人脸识别的方法为cvHaarDetectObject方法，传入待检测的图片，分类器等参数，最终可以获得识别到的人脸信息。</span><span class='green'>OpenCV中使用CVSeq数据结构进行存储。</span><span class='green'>使用CVSeq数组faces存储检测到的人脸。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">193</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在完成这个过程后，由于在onPreviewFrame中调用了postInvalidate方法进行view的重绘，因此会重新调用faceview的onDraw方法。</span><span class='green'>在onDraw方法中会从FaceRecognizer中取出检测到的人脸，根据人脸的信息来在屏幕上绘制矩阵。</span><span class='green'>只需要调用canvas的drawRect方法就可以方便的进行矩阵绘制。</span><a href='../sentence_detail/447.htm' target='right' class='orange' >根据检测到的人脸数量绘制相应数量的人脸矩阵。</a><span class='green'>实现的关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">194</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，人脸检测的过程就已经完成了。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">195</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.4 人脸检测实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">196</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/451.htm' target='right' class='orange' >人脸识别之前先要对所有的样本图片进行训练，在此之前要先进行样本的采集。</a><span class='green'>首先在人脸采集页面添加EditText，使用户可以输入姓名。</span><a href='../sentence_detail/453.htm' target='right' class='orange' >在姓名输入完成后，点击保存按钮会跳转拍照页面。</a><span class='green'>这里利用了Android的Intent机制，通过给Intent设置Action：</span><span class='green'>ACTION_IMAGE_CAPTURE，可以调用系统的拍摄页面，只需要在onActivityResult中处理拍摄完成的结果即可。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">197</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在获取到人脸图像后，还需要对图像进行裁剪，来使得人脸占图像比例尽量大。</span><span class='green'>裁剪也是利用Intent机制，给Intent设置Action：</span><span class='green'>com.android.camera.action.CROP。</span><span class='green'>并且通过Intent的putExtra方法来添加裁剪参数。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">198</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最后需要将拍摄的图片保存到本地。</span><span class='green'>使用Android的File类可以完成。</span><span class='green'>首先通过 File的 createTempFile方法创建一个图片文件，文件名使用姓名加上当前的时间戳，再将这个图片文件传入跳转裁剪页面的 Intent对象中，</span><span class='green'>Android系统会在完成裁剪后将裁剪好的图像根据传入的图片文件保存到本地。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">199</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.4人脸识别流程</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">200</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>人脸识别部分使用的OpenCV的FaceRecognizer类。</span><a href='../sentence_detail/467.htm' target='right' class='orange' >在完成人脸检测部分的初始化后会进行FaceRecognizer对象的初始化。</a><a href='../sentence_detail/468.htm' target='right' class='orange' >由于要对所有的人脸样本进行训练，所以首先要获取所有人脸样本。</a><span class='green'>通过Android的文件系统，首先找到人脸样本的目录，通过File对象的listFiles可以获得所有人脸样本。</span><span class='green'>在获取到人脸样本后先要将其转换成灰度图，方法与人脸检测部分图片转换成灰度图相同。</span><span class='green'>通过createLBPFaceRecognizer方法可以新建一个FaceRecognizer对象。</span><span class='green'>训练图片只需要调用FaceRecognizer的train方法。</span><span class='green'>train方法要求传入MatVector对象和int数组。</span><span class='green'>也就是OpenCV图片向量与其对应的标签。</span><span class='green'>通过一个循环即可完成人脸样本到MatVector对象与对应标签的转换。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">201</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/477.htm' target='right' class='orange' >在人脸检测完成之后，如果检测到人脸就会调用predictFace方法来进行人脸识别，并且传入待检测的人脸。</a><span class='green'>人脸识别时会调用FaceRecognizer的predict方法，这个方法会在识别完成后返回一个label，表示识别出的人脸在人脸数组中的位置。</span><span class='green'>通过遍历即可获得识别出的人的姓名。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">202</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在Faceview中，FaceRecognizer的ProcessImage方法回返回识别到的人的姓名。</span><span class='green'>在FaceView的onDraw方法中会判断是否有识别到的人脸，如果存在，则调用canvas的drawText方法把姓名显示到屏幕上。</span><span class='green'>效果图如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">203</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-4 人脸识别效果图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">204</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第6章 关键问题及解决方法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">205</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>6.1 摄像头预览部分</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">206</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在进行摄像头预览时在部分机型上未响应。</span><span class='green'>测试过后发现在部分Android6.0以上手机上未获取到摄像头权限。</span><span class='green'>Android M采用了不同于其他版本的动态权限管理，部分权限不会在安装时就获得，需要动态申请。</span><span class='green'>如果未获取到目标权限，相关操作不会有任何返回值。</span><span class='green'>需要将Target SDK设置为23或23以上，然后在代码判断是否获取到了权限，然后动态请求获取权限。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">207</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在进行摄像头预览时程序奔溃，提示setParameters failed。</span><span class='green'>在进行摄像头预览时需要设置预览时的宽度和高度。</span><span class='green'>这时需要先获取摄像头支持的宽度和高度，然后与用于预览的 SurfaceView的宽度和高度进行比较，当宽高比小于阈值并且高度与某一支持的高度最相近的时候，</span><span class='green'>就采用这个宽高作为预览时 Camera的输出宽高。</span><span class='green'>如果设置了Camera不支持的宽高，则程序运行时就会报错。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2016 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
