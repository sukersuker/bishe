<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：4/6页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">121</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Haar分类器包含了Adaboot算法。</span><a href='../sentence_detail/299.htm' target='right' class='red' >分类器是数据挖掘的一种重要概念。</a><a href='../sentence_detail/300.htm' target='right' class='orange' >分类器把有限数据分成若干个类，任何一个新的数据都可以映射到某一个类中，从而可以对数据进行预测。</a><a href='../sentence_detail/301.htm' target='right' class='orange' >比如在这里，分类器将所有的样本分成两类，第一类是人脸，第二类是非人脸。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">122</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/302.htm' target='right' class='orange' >Haar分类器实际上是Boosting算法的一个应用，Haar分类器用到了Boosting算法中的Adaboot算法。</a><a href='../sentence_detail/303.htm' target='right' class='orange' >Haar分类器将AdaBoost算法训练出的强分类器进行了联级。</a><a href='../sentence_detail/304.htm' target='right' class='orange' >Haar分类器是由Haar-Like特征、积分图方法、AdaBoost组成的。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">123</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.1.1 Haar-Like特征</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">124</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/306.htm' target='right' class='orange' >Haar-like特征在最早的时候是用于人脸表示的，由Papageorgiou等提出。</a><span class='green'>Haar特征分为3类：</span><a href='../sentence_detail/308.htm' target='right' class='red' >边缘特征、线性特征、中心特征和对角线特征，共同组合成特征模板。</a><a href='../sentence_detail/309.htm' target='right' class='orange' >在这个特征模板中分成了两种颜色的矩形，白色和黑色，定义模板的特征值为白色矩形像素减去黑色矩形像素和。</a><span class='green'>Haar特征值反映的是图像在灰度上的变化。</span><span class='green'>例如其在人脸上的表现为：</span><span class='green'>眼睛比鼻子的颜色深；</span><span class='green'>嘴巴颜色比周围颜色深。</span><a href='../sentence_detail/314.htm' target='right' class='orange' >由于特征是矩形的，所以其只能描述特定走向的边缘或线段结构。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">125</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4.1特征模板</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">126</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/316.htm' target='right' class='red' >对于图中A，B和D这几种特征，特征数值计算公式是：</a><span class='green'>v=白色的和-黑色的和。</span><span class='green'>但是对于C来说，计算公式为：</span><span class='green'>v=白色的和-2*黑色的和。</span><a href='../sentence_detail/320.htm' target='right' class='orange' >黑色区域乘二是为了使两种矩形区域中的像素数量相同。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">127</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/321.htm' target='right' class='orange' >矩形特征可以在图像的任意位置，可以设置任意大小，可以选定不同的矩形模板类别。</a><span class='green'>因此，在极小的检测窗口也可能会有大量的矩形特征。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">128</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.1.2 AdaBoost</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">129</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/324.htm' target='right' class='orange' >AdaBoost实际上是一种具有一般性的用来提升分类器的算法它并不局限使用某一特定的分类器。</a><span class='green'>AdaBoost可以帮助我们更好地选择矩阵特征的组合，矩阵特征组合将以二叉决策树的形式存储起来。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">130</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/326.htm' target='right' class='red' >AdaBoost的核心思想是针对同一个训练集训练不同的若干个弱分类器，最终将这些弱分类器组合成一个强分类器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">131</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Adaboost算法是通过迭代实现的，其中重要的一步是更改数据的分布。</span><a href='../sentence_detail/328.htm' target='right' class='orange' >根据每次训练集中样本是否正确来给样本设置权值，然后把划分权值的分类器传递给下层分类器进行训练，</a><a href='../sentence_detail/329.htm' target='right' class='red' >将每次训练得到的弱分类器融合，得到最终的强分类器。</a><span class='green'>具体过程如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">132</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/331.htm' target='right' class='orange' >（1）对N个训练样本进行学习，得到第一个弱分类器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">133</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/332.htm' target='right' class='orange' >（2）使用测试样本进行测试，将分错的样本和其他的新样本构成一个新的样本数为N的训练样本，学习得到第二个弱分类器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">134</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/333.htm' target='right' class='orange' >（3）把（1）和（2）测试出来分错的样本加上若干新的样本组成N个训练样本，学习得到第三个弱分类器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">135</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/334.htm' target='right' class='orange' >（4）反复进行上面的步骤，学习得到若干个弱分类器，最终组合成一个强分类器。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">136</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/335.htm' target='right' class='orange' >AdaBoost算法对分错的样本进行了加权，使得训练的焦点放在了比较难区分的训练样本上。</a><a href='../sentence_detail/336.htm' target='right' class='orange' >该算法还对弱分类器进行了加权处理，使得分类效果较好的分类器具有比较高的权重，分类效果差的分类器具有较小的权重。</a><span class='green'>[9]</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">137</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4.2权重处理</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">138</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.1.3 积分图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">139</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/340.htm' target='right' class='red' >积分图是只遍历一次图像就可以求出图像中所有区域像素和的快速算法，大大提升了图像特征值计算的效率。</a><a href='../sentence_detail/341.htm' target='right' class='orange' >在进行 haar- like分类器训练和检测的过程中，每当遇到图片样本的时候都会需要计算某一个窗口的特征值，</a><span class='green'>这样的计算是非常大的，而积分图就可以解决 haar- like计算量过大的问题。</span><a href='../sentence_detail/343.htm' target='right' class='red' >积分图是一种可以描述全局信息的矩阵表示方法。</a><a href='../sentence_detail/344.htm' target='right' class='red' >积分图的构造方法是位置（i，j）处的值ii（i，j）是原图像（i，j）左上角方向所有像素的和：</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">140</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>积分图的构建算法如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">141</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）用s（i ， j）表示行方向的累加和，初始化s(i，-1)=0;</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">142</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）用ii(i ， j)表示一个积分图像，初始化ii(-1，i)=0；</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">143</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/348.htm' target='right' class='red' >（3）逐行扫描图像，递归计算每个像素(i ， j)行方向的累加和s(i ， j)和积分图像ii(i ，j)的值</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">144</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（4）s(i ，j)=s(i ，j-1)+f(i ， j)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">145</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（5）ii(i，j)=ii(i-1，j)+s(i，j)</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">146</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/351.htm' target='right' class='red' >（6）扫描图像一遍，当到达图像右下角像素时，积分图像ii就构造好了。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">147</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/352.htm' target='right' class='red' >（7）积分图构造好之后，图像中任何矩阵区域的像素累加和都可以通过简单运算得到如图所示。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">148</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（8）设D的四个顶点分别为α、β、γ、δ，则D的像素和可以表示为</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">149</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（9）Dsum = ii( α )+ii( β)-(ii( γ)+ii( δ ));</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">150</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>4.2 LBP算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">151</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>LBP算法，Local Binary Patterns，局部二值模式。</span><span class='green'>是一种使用局部特征作为判别依据的识别算法。</span><span class='green'>使用LBP时，图像必须为灰度图。</span><a href='../sentence_detail/359.htm' target='right' class='orange' >每张灰度图都是由一个一个像素点组成，每个像素点都有自己的灰度。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">152</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>LBP算法最初是定义在一个3×3的一个邻域内的，以中间的点作为阈值，</span><a href='../sentence_detail/361.htm' target='right' class='orange' >将邻近的8个像素的灰度值与中间这个像素的灰度值进行对比，如果大于中心点的灰度值，</a><span class='green'>则记为1，如果小于中心点的灰度值，则记为0。</span><span class='green'>这样在每个点对比过后，可以得到一个8位的2进制数，即这个邻域的LBP值。</span><span class='green'>这个值表现的是这个邻域的纹理信息[12]。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">153</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4.3 LBP算法示意图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">154</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>正式公式为：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">155</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中 表示中间的那个点。</span><a href='../sentence_detail/368.htm' target='right' class='orange' >ic表示中间点的灰度值，ip表示邻域的点的灰度值。</a><span class='green'>S（x）是符号函数，定义如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">156</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最初的LBP算法存在着缺陷，它无法应对不同尺寸和不同频率纹理以及旋转的情况。</span><span class='green'>因此Ojala对LBP算法进行了改进。</span><span class='green'>他将3乘3的邻域改成了任意大小的邻域，并且并且由原来的正方形改成了圆形。</span><span class='green'>类似于下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">157</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>假设圆的半径为R，其中有P个采样点，其中每个采样点的值可以用下面的公式表示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">158</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中 为中心点， 为某个采样点，通过上式可以计算出每个采样点的坐标值，但是坐标并不一定是整数值，可以通过双线性插值计算得到采样点的像素：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">159</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在获取到人脸的LBP特征后还需要进行特征匹配，例如下面这张人脸图像，将其划分</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">160</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为7×7的子区域并计算得到每个邻域的LBP值并且统计其直方图。</span><a href='../sentence_detail/378.htm' target='right' class='orange' >这样做可以避免人脸没有完全对准的情况，也对LBP特征进行了降维处理。</a><span class='green'>在得到直方图后，有多种方法可以判别其相似性。</span><span class='green'>可以使用：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">161</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）直方图交叉核算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">162</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）卡方统计方法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">163</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中Mi为已知人脸直方图，Si为待匹配人脸直方图。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">164</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第5章 系统实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">165</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1 系统总体结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">166</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统总体结构如图5.1</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">167</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-1 总体结构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">168</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本系统使用Android Studio作为集成开发环境。</span><span class='green'>Android Studio使用Gradle对项目进行构建。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">169</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Project名字是FaceRecognizer，它代表了整个工作区。</span><span class='green'>faceRecognizer是Project中的一个Module。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">170</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>manifests下的AndroidManifest.xml文件是Android应用的配置文件。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">171</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>java文件夹下放置的是module下所有的java文件。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">172</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>jniLibs文件夹下放置的是不同平台下的动态链接库。</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_3.htm">上一页</a>
<a class="pagelink" href="paper_5.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：4/6页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2016 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
