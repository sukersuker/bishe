<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN""http://www.w3.org/TR/html4/loose.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="content-type" content="text/html; charset=utf-8" />
<title>PaperPass 最权威论文抄袭检测系统</title>
<style type="text/css">
<!--
user_icon {
color: #FFFFFF;
}
html
{
overflow-x:hidden;
overflow-y:auto;
}
body,td,th {
font-family: "微软雅黑";
font-size: 12px;
}
h1,h2,h3,h4,h5,h6 {
font-family: "宋体";
}
p{
margin-bottom:10px;
}
demo_padding {
line-height: 30px;
}
.zhengwen {
padding-right: 15px;
padding-left: 5px;
padding-bottom:100px;
font-size: 13px;
line-height: 20px;
color: #666666;
}
.zhengwencenter {
padding-right: 15px;
padding-left: 0px;
margin-bottom:10px;
font-size: 13px;
line-height: 20px;
color: #666666;
text-align:center
}
.neikuang {
background-color: #EBEBEB;
border: 1px solid #999999;
padding-right: 10px;
padding-left: 10px;
margin-top:10px;
margin-left:25px;
width:300px;
}
.shubu{
height: 20px;
width: 20px;
margin-left:25px;
background-color: #FFFFFF;
border: 1px solid #999999;
text-align: center;
vertical-align: middle;
display: block;
color: #666666;
}
a.red:link {color:#FF0000}
a.red:visited {color:#FF0000}
a.red:hover {color:#000000}
a.red:active {color:#000000}

a.orange:link {color:#FF6600}
a.orange:visited {color:#FF6600}
a.orange:hover {color:#000000}
a.orange:active {color:#000000}

a.dark:link {color:#666666}
a.dark:visited {color:#666666}
a.dark:hover {color:#000000}
a.dark:active {color:#000000}

a.pagelink:hover {color:#000000}
a.pagelink:active {color:#000000}

.green{color:#008000}
.gray{color:#666666}
.red{color:#FF0000}
.orange{color:#FF6600}
a{TEXT-DECORATION:none}

-->
</style>
</head>
<body>


<div class="zhengwen">
<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">196</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>LBP算法，英文全称为Local Binary Patterns，中文名称为局部二值模式。</span><span class='green'>LBP算法通过局部特征来对图像进行判别。</span><span class='green'>使用LBP时，图像必须为灰度图。</span><a href='../sentence_detail/399.htm' target='right' class='orange' >每张灰度图都是由一个一个像素点组成，每个像素点都有自己的灰度。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">197</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/400.htm' target='right' class='orange' >相比较于其他人脸识别算法，LBP算法的优势是对光照并不敏感。</a><span class='green'>这在人脸识别时是非常重要的一点，在实际的识别过程中，识别的人脸可能处于不同的光照强度之下，</span><span class='green'>如果与样本的光照强度差别太大，并且识别算法对光照较敏感，则很有可能无法正确的识别出人脸。</span><span class='green'>这是LBP算法的一大优势。</span><span class='green'>LBP算法的另一个优势是计算速度快。</span><span class='green'>LBP算法的计算方法特别简单，可以在非常短的时间时间内完成计算，并且拥有较高的识别成功率。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">198</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>LBP算法最初是定义在一个3×3的一个邻域内的，以中间的点作为阈值，</span><a href='../sentence_detail/407.htm' target='right' class='orange' >找到与它相邻的8个像素，与中间像素的灰度值进行对比，如果大于中心点的灰度值，</a><span class='green'>则记为1，如果小于中心点的灰度值，则记为0。</span><span class='green'>这样在每个点对比过后，可以得到一个8位的2进制数，即这个邻域的LBP值。</span><span class='green'>这个值表现的是这个邻域的纹理信息[12]。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">199</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4.5 LBP算法示意图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">200</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>正式公式为：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">201</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中 代表的是中间的点。</span><a href='../sentence_detail/414.htm' target='right' class='orange' >ic表示中间点的灰度值，ip表示邻域的点的灰度值。</a><span class='green'>S（x）是符号函数，有如下的定义：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">202</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>最初的LBP算法存在着缺陷，它无法应对不同尺寸和不同频率纹理以及旋转的情况。</span><span class='green'>奥加拉对LBP算法进行了相应的改进。</span><span class='green'>他将3乘3的邻域拓展成任意大小的邻域，由于正方形的形状的局限性，它将领域改成了圆形。</span><span class='green'>类似于下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">203</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-6 LBP算法圆形邻域</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">204</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>假设圆的半径为R，其中有P个采样点，其中每个采样点的值可以用下面的公式表示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">205</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中 为中心点， 为某个采样点，通过上式可以计算出每个采样点的坐标值，但是坐标并不一定是整数值，可以通过双线性插值计算得到采样点的像素：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">206</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在获取到人脸的LBP特征后还需要进行特征匹配，例如下面这张人脸图像，将其划分</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">207</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图4-7 人脸的LBP划分</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">208</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>为7×7的子区域并计算得到每个邻域的LBP值并且统计其直方图。</span><span class='green'>在得到直方图后，下面两种方法都可以判断其相似性。</span><span class='green'>算法公式如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">209</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（1）直方图交叉核算法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">210</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>（2）卡方统计方法</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">211</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>第5章 系统实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">212</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.1 系统总体结构</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">213</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>系统总体结构如图5.1</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">214</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-1 总体结构图</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">215</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>本系统使用的Android开发IDE是Android Studio。</span><span class='green'>与Eclipse不同的是，Android Studio使用Gradle进行构建。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">216</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Project名字是FaceRecognizer，它代表了整个工作区。</span><span class='green'>faceRecognizer是Project中的一个Module。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">217</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Manifests表示配置，里面有个AndroidManifest.xml文件，用于对Android应用进行配置。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">218</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Java文件夹就是用来存放Java代码的。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">219</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>jniLibs文件夹下放置的是不同平台下的动态链接库。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">220</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Res文件夹可以放置各种资源文件，例如图片，布局文件，动画等。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">221</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>resources文件夹可以用来存放本地文件。</span><a href='../sentence_detail/443.htm' target='right' class='orange' >在项目中这个文件夹存放的是已经训练好的分类器文件。</a>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">222</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Gradle Scripts存放的是Gradle脚本，如下图所示：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">223</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-2 gradle脚本</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">224</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>其中build.gradle表示Project或者Module的构建脚本。</span><span class='green'>Proguard-rules.pro表示混淆规则。</span><span class='green'>gradle.properties表示gradle特性，可以对构建过程进行设置。</span><span class='green'>setting.gradle可以对Gradle的Module进行管理。</span><span class='green'>可以通过local.properties对SDK或NDK进行管理。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">225</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.2 视频预览实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">226</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>视频预览的实现涉及到Android的SurfaceView类和SurfaceView类。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">227</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>SurfaceView继承于View，可以直接从内存或者DMA等硬件接口取得图像数据。</span><span class='green'>它的特点是：</span><span class='green'>通常在 Android中， UI的绘制只能在主线程中进行，但是在绘图频繁进行的情况下，主线程会被阻塞，</span><span class='green'>而 SurfaceView可以实现在主线程以外的线程进行图像的绘制，使用 SurfaceView可以防止 UI线程阻塞，可以用于摄像头预览。</span><span class='green'>使用SurfaceView需要继承SurfaceView，并且实现SurfaceView的Callback接口，如下图：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">228</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在构造函数中首先为SurfaceView的Holder添加一个实现了Callback的回调。</span><span class='green'>这个Callback有3个回调函数：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">229</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在这3个回调函数里对Camera进行操作。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">230</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>Camera类是在Android中是用来对摄像头进行一些操作的。</span><span class='green'>首先需要通过Camera.open()来获取一个Camera实例，然后使用setPreviewDisplay方法来为Camera设置一个SurfaceView对象，将其作为预览容器。</span><span class='green'>使用Camera.Parameters可以对Camera的各个参数进行设置。</span><span class='green'>常见的参数有预览的大小和摄像头预览的方向。</span><span class='green'>想要获取到每帧图像的大小，只要为camera设置一个PreviewCallback回调。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">231</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>至此，已经完成了预览的流程。</span><span class='green'>实现效果如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">232</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>图5-3视频预览画面</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">233</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>5.3 人脸检测实现</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">234</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在上一节中提到需要为Camera对象设置一个PreviewCallback回调。</span><span class='green'>创建了一个继承于View的FaceView来负责人脸信息的绘制。</span><span class='green'>FaceView实现了Camera的PreviewCallback，重写了onPreviewFrame方法。</span><span class='green'>OnPreviewFrame接收摄像头获取到的图像数据，每当获取到一帧，就回调一次。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">235</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><a href='../sentence_detail/475.htm' target='right' class='orange' >FaceRecognizer类负责人脸检测和人脸识别。</a><span class='green'>在FaceView的构造函数中，对FaceRecognizer进行了初始化。</span><a href='../sentence_detail/477.htm' target='right' class='orange' >人脸检测的初始化是加载分类器，分类器保存在resources文件夹中。</a><a href='../sentence_detail/478.htm' target='right' class='orange' >由于加载分类器是一个耗时操作，因此要放到一个新的线程中使用。</a><a href='../sentence_detail/479.htm' target='right' class='orange' >主要使用JavaCV的CVHaarClassifierCascade类，在初始化时只需要传入分类器文件的路径。</a><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">236</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>由于加载分类器是一个耗时的操作，因此会新开一个线程进行加载，在完成加载后调用主线程创建的 Handler来发送一个消息给主线程，</span><span class='green'>表明加载完成，然后进行相应的 UI更新。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">237</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>而当FaceView接收到预览图像一帧的回调时，将获取到的图像数据传递给FaceRecognizer对象。</span><span class='green'>关键代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">238</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在processImage方法中会先将获取到的图像转换成OpenCV中图片的数据结构，即IplImage。</span><span class='green'>直接调用IplImage的create方法即可。</span><span class='green'>在将其转换成IplImage之后再将其转换成灰度图。</span><span class='green'>具体实现代码如下：</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">239</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>进行人脸识别的方法为cvHaarDetectObject方法，传入待检测的图片，分类器等参数，最终可以获得识别到的人脸信息。</span><span class='green'>OpenCV中使用CVSeq数据结构进行存储。</span><span class='green'>使用CVSeq数组faces存储检测到的人脸。</span>
</p>
</div>

<div>
<p>
<table border="0" width="100%" cellspacing="0" cellpadding="0">
<tr>
<td align="left" width="50"><div class="shubu">240</div></td>
<td>&nbsp;&nbsp;</td>
</tr>
</table>

<span style="margin-left:25px"></span><span class='green'>在完成这个过程后，由于在onPreviewFrame中调用了postInvalidate方法进行view的重绘，因此会重新调用faceview的onDraw方法。</span><span class='green'>在onDraw方法中会从FaceRecognizer中取出检测到的人脸，根据人脸的信息来在屏幕上绘制矩阵。</span><span class='green'>只需要调用canvas的drawRect方法就可以方便的进行矩阵绘制。</span><a href='../sentence_detail/495.htm' target='right' class='orange' >根据检测到的人脸数量绘制相应数量的人脸矩阵。</a><span class='green'>实现的关键代码如下：</span>
</p>
</div>


<div>
<span style="margin-left:25px"></span>
[
<a class="pagelink" href="paper_1.htm">首页</a>
<a class="pagelink" href="paper_4.htm">上一页</a>
<a class="pagelink" href="paper_6.htm">下一页</a>
<a class="pagelink" href="paper_6.htm">尾页</a>
页码：5/6页
]
</div>

<br>
<div style="margin-left:8px">

<div style="text-align:center;background-color:#CA122C;margin-top:30px;overflow:hidden;">
<a href="http://www.paperpass.com/publish/index?from=ppreport_banner" target="_blank" style="display:block;"><img height="180" src="http://file.paperpass.com/images/fabiao.jpg"></a>
</div>

</div>
</div>


<div class="zhengwencenter">
<p>
检测报告由<a href="http://www.paperpass.com/" target="_blank">PaperPass</a>文献相似度检测系统生成
</p>
<p>
Copyright © 2007-2016 PaperPass
</p>
</div>
<div style="margin-bottom:400px"></div>
</body>
</html>
